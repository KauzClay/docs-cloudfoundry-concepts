---
title: Routing Architecture
owner: CF Routing
---

This topic explains routing flow and architecture in Cloud Foundry.

## <a id='routing-flow'></a> Routing Flow and Architecture Diagram

The following process describes how an external client makes a request to an app running on Cloud Foundry:

1. The external client sends its request.

1. The external client's DNS name determines whether the request will go to the HTTP load balancer or TCP load balancer.

1. From the load balancer, the request goes to the load balancer's corresponding router.

1. From the router, the request goes to the app.


<img src="images/external-client-call-app.png" alt="" width="500">


## <a id='route-info-flow'></a> Route Information Flow and Architecture Diagram

The following process describes how a router obtains information about routes for an app running on Cloud Foundry:

1. The Cloud Controller component sends its route metadata to Diego BBS.

1. Diego BBS sends its IP and port metadata along with Cloud Controller's route metadata to the route emitter on the Diego cell where instances of the app are located.

1. If a route is HTTP, the route emitter on the Diego cells sends route, IP, and port metadata to NATS, which then sends it to the Gorouter. If a route is TCP, the route emitter sends that metadata to the Routing API, which then sends it to the TCP router.

1. The route comes from Cloud Controller, and the location of an app instance comes from Diego; together, they map the route that the Gorouter or TCP router needs to process requests. When the Gorouter or TCP router receive requests, they match the route information they receive against addresses in their in-memory database. Once there is a match, they can look up back end locations.

Cloud Controller and Diego BBS have their own databases, while NATS and the Gorouter do not. To compensate for this disparity, the route emitter sends information about the routes it knows about from Cloud Controller and Diego BBS to NATS and the Gorouter every twenty seconds. If the Gorouter does not receive information about a route within two minutes, it prunes that route from its database.

The router periodically queries Diego BBS to determine which cells and containers each app currently runs on. Using this information, the router recomputes new routing tables based on the IP addresses of each cell virtual machine (VM) and the host-side port numbers for the cell's containers.

Each route can be mapped to an app, and because an app can have many instances, one route can go to multiple containers.

![](cf-routing-architecture.png)


## <a id='routing-components'></a> Routing Architecture Components

The following summarizes the roles and responsibilities of various components depicted in the Cloud Foundry routing architecture diagram above. These summaries are limited to the roles and responsibilities these components have pertaining to routing. For more complete descriptions of these components, see [](), [](), and []().

| Component Name | Summary |
|----------------|---------|
| Cloud Controller | Sends route metadata, including whether they are HTTP or TCP, to Diego BBS and route emitter. |
| Diego BBS | Sends IP and port metadata to route emitter, along with route metadata from Cloud Controller. |
| Diego cell | Manages app instances and tasks and long-running processes related to them. Houses route emitter. |
| Route emitter | Periodically emits route, IP, and port metadata along with registration and unregistration messages for instances running on the local cell to NATS or Routing API. Does not know about app instances on Diego cell, but knows what cell it belongs to and asks Diego BBS for information about apps on the same cell. |
| NATS | Publish-subscribe and distributed queueing messaging system. Sends route metadata to the Gorouter. |
| Routing API | Registers and deregisters routes for external and internal clients. Gets information from route emitter and routing database. |
| Routing database | Stored within internal MySQL cluster. If the Gorouter misses a message about an unmapped route from NATS, it will not get it again, so the TCP router and routing API can consult database for current state of routes. |
| Gorouter | Routes traffic coming into Cloud Foundry to the appropriate component. Receives route updates throughÂ NATS. Routes that have not been updated in two minutes are pruned from the Gorouter's database. |
| TCP router | Routes traffic coming into Cloud Foundry to the appropriate component. Receives route updates through the routing API. |
| BOSH manifest | Sends route metadata for system components, such as UAA and Loggregator, to the route registrar. |
| Route registrar | Gets route metadata for system components, such as UAA and Loggregator, from the BOSH manifest and sends it to NATS. This is because the Diego cell does not have information about system components, only about user spaces. |
